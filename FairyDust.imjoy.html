<docs lang="markdown">
    Describe your plugin here.
</docs>

<config lang="json">
    {
    "name": "Fairy Dust",
    "type": "window",
    "tags": [],
    "ui": null,
    "version": "0.1.3",
    "api_version": "0.1.2",
    "description": "Display point cloud in 2D/3D",
    "icon": "extension",
    "inputs": null,
    "outputs": null,
    "requirements": [
    "https://cdnjs.cloudflare.com/ajax/libs/three.js/r49/Three.js",
    "https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"],
    "dependencies": []
    }
</config>

<script lang="javascript">
    /**
     * @author Eberhard Graether / http://egraether.com/
     */
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    var is2D;

    const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    const {
        Quaternion,
        Vector2,
        Vector3
    } = THREE;

    const _changeEvent = { type: 'change' };
    const _startEvent = { type: 'start' };
    const _endEvent = { type: 'end' };

    class TrackballControls {
        dispatchEvent(evt) {
            // console.log(evt)
        }

        constructor(object, domElement) {
            if (domElement === undefined) console.warn('THREE.TrackballControls: The second parameter "domElement" is now mandatory.');
            if (domElement === document) console.error('THREE.TrackballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');

            const scope = this;
            const STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

            this.object = object;
            this.domElement = domElement;

            // API

            this.enabled = true;

            this.screen = { left: 0, top: 0, width: 0, height: 0 };

            this.rotateSpeed = 1.0;
            this.zoomSpeed = 1.2;
            this.panSpeed = 0.3;

            this.noRotate = false;
            this.noZoom = false;
            this.noPan = false;

            this.staticMoving = false;
            this.dynamicDampingFactor = 10;

            this.minDistance = 0;
            this.maxDistance = Infinity;

            this.keys = ['KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/];

            this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

            // internals

            this.target = new Vector3();

            const EPS = 0.000001;

            const lastPosition = new Vector3();
            let lastZoom = 1;

            let _state = STATE.NONE,
                _keyState = STATE.NONE,

                _touchZoomDistanceStart = 0,
                _touchZoomDistanceEnd = 0,

                _lastAngle = 0;

            const _eye = new Vector3(),

                _movePrev = new Vector2(),
                _moveCurr = new Vector2(),

                _lastAxis = new Vector3(),

                _zoomStart = new Vector2(),
                _zoomEnd = new Vector2(),

                _panStart = new Vector2(),
                _panEnd = new Vector2();

            // for reset

            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.up0 = this.object.up.clone();
            this.zoom0 = this.object.zoom;

            // methods

            this.handleResize = function () {

                const box = scope.domElement.getBoundingClientRect();
                // adjustments come from similar code in the jquery offset() function
                const d = scope.domElement.ownerDocument.documentElement;
                scope.screen.left = box.left + window.pageXOffset - d.clientLeft;
                scope.screen.top = box.top + window.pageYOffset - d.clientTop;
                scope.screen.width = box.width;
                scope.screen.height = box.height;

            };

            const getMouseOnScreen = (function () {

                const vector = new Vector2();

                return function getMouseOnScreen(pageX, pageY) {

                    vector.set(
                        (pageX - scope.screen.left) / scope.screen.width,
                        (pageY - scope.screen.top) / scope.screen.height
                    );

                    return vector;

                };

            }());

            const getMouseOnCircle = (function () {

                const vector = new Vector2();

                return function getMouseOnCircle(pageX, pageY) {

                    vector.set(
                        ((pageX - scope.screen.width * 0.5 - scope.screen.left) / (scope.screen.width * 0.5)),
                        ((scope.screen.height + 2 * (scope.screen.top - pageY)) / scope.screen.width) // screen.width intentional
                    );

                    return vector;

                };

            }());

            this.rotateCamera = (function () {

                const axis = new Vector3(),
                    quaternion = new Quaternion(),
                    eyeDirection = new Vector3(),
                    objectUpDirection = new Vector3(),
                    objectSidewaysDirection = new Vector3(),
                    moveDirection = new Vector3();

                return function rotateCamera() {

                    moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
                    let angle = moveDirection.length();

                    if (angle) {

                        _eye.copy(scope.object.position).subSelf(scope.target);

                        eyeDirection.copy(_eye).normalize();
                        objectUpDirection.copy(scope.object.up).normalize();
                        objectSidewaysDirection.cross(objectUpDirection, eyeDirection).normalize();

                        objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
                        objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

                        moveDirection.copy(objectUpDirection.addSelf(objectSidewaysDirection));

                        axis.cross(moveDirection, _eye).normalize();

                        angle *= scope.rotateSpeed;
                        quaternion.setFromAxisAngle(axis, angle);

                        // _eye.applyQuaternion( quaternion );
                        // scope.object.up.applyQuaternion( quaternion );
                        quaternion.multiplyVector3(_eye)
                        quaternion.multiplyVector3(scope.object.up)

                        _lastAxis.copy(axis);
                        _lastAngle = angle;

                    } else if (!scope.staticMoving && _lastAngle) {

                        _lastAngle *= Math.sqrt(1.0 - scope.dynamicDampingFactor);
                        _eye.copy(scope.object.position).subSelf(scope.target);
                        quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
                        // _eye.applyQuaternion( quaternion );
                        // scope.object.up.applyQuaternion( quaternion );
                        quaternion.multiplyVector3(_eye)
                        quaternion.multiplyVector3(scope.object.up)

                    }

                    _movePrev.copy(_moveCurr);

                };

            }());


            this.zoomCamera = function () {

                let factor;

                if (_state === STATE.TOUCH_ZOOM_PAN) {

                    factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
                    _touchZoomDistanceStart = _touchZoomDistanceEnd;

                    // if ( scope.object.isPerspectiveCamera ) {

                    _eye.multiplyScalar(factor);

                    // } else if ( scope.object.isOrthographicCamera ) {

                    // 	scope.object.zoom *= factor;
                    // 	scope.object.updateProjectionMatrix();

                    // } else {

                    // 	console.warn( 'THREE.TrackballControls: Unsupported camera type' );

                    // }

                } else {

                    factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * scope.zoomSpeed;

                    if (factor !== 1.0 && factor > 0.0) {

                        // if ( scope.object.isPerspectiveCamera ) {

                        _eye.multiplyScalar(factor);

                        // } else if ( scope.object.isOrthographicCamera ) {

                        // 	scope.object.zoom /= factor;
                        // 	scope.object.updateProjectionMatrix();

                        // } else {

                        // 	console.warn( 'THREE.TrackballControls: Unsupported camera type' );

                        // }

                    }

                    if (scope.staticMoving) {

                        _zoomStart.copy(_zoomEnd);

                    } else {

                        _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;

                    }

                }

            };

            this.panCamera = (function () {

                const mouseChange = new Vector2(),
                    objectUp = new Vector3(),
                    pan = new Vector3();

                return function panCamera() {

                    mouseChange.copy(_panEnd).subSelf(_panStart);

                    if (mouseChange.lengthSq()) {

                        if (scope.object.isOrthographicCamera) {

                            const scale_x = (scope.object.right - scope.object.left) / scope.object.zoom / scope.domElement.clientWidth;
                            const scale_y = (scope.object.top - scope.object.bottom) / scope.object.zoom / scope.domElement.clientWidth;

                            mouseChange.x *= scale_x;
                            mouseChange.y *= scale_y;

                        }

                        mouseChange.multiplyScalar(_eye.length() * scope.panSpeed);

                        pan.copy(_eye).crossSelf(scope.object.up).setLength(mouseChange.x);
                        pan.addSelf(objectUp.copy(scope.object.up).setLength(mouseChange.y));

                        scope.object.position.addSelf(pan);
                        scope.target.addSelf(pan);

                        if (scope.staticMoving) {

                            _panStart.copy(_panEnd);

                        } else {

                            _panStart.addSelf(mouseChange.sub(_panEnd, _panStart).multiplyScalar(scope.dynamicDampingFactor));

                        }

                    }

                };

            }());

            this.checkDistances = function () {

                if (!scope.noZoom || !scope.noPan) {

                    if (_eye.lengthSq() > scope.maxDistance * scope.maxDistance) {

                        scope.object.position.add(scope.target, _eye.setLength(scope.maxDistance));
                        _zoomStart.copy(_zoomEnd);

                    }

                    if (_eye.lengthSq() < scope.minDistance * scope.minDistance) {

                        scope.object.position.add(scope.target, _eye.setLength(scope.minDistance));
                        _zoomStart.copy(_zoomEnd);

                    }

                }

            };

            this.update = function () {

                _eye.sub(scope.object.position, scope.target);

                if (!scope.noRotate) {

                    scope.rotateCamera();

                }

                if (!scope.noZoom) {

                    scope.zoomCamera();

                }

                if (!scope.noPan) {

                    scope.panCamera();

                }

                scope.object.position.add(scope.target, _eye);

                // if ( scope.object.isPerspectiveCamera ) {

                scope.checkDistances();

                scope.object.lookAt(scope.target);

                if (lastPosition.distanceToSquared(scope.object.position) > EPS) {

                    scope.dispatchEvent(_changeEvent);

                    lastPosition.copy(scope.object.position);

                }

                // } else if ( scope.object.isOrthographicCamera ) {

                // 	scope.object.lookAt( scope.target );

                // 	if ( lastPosition.distanceToSquared( scope.object.position ) > EPS || lastZoom !== scope.object.zoom ) {

                // 		scope.dispatchEvent( _changeEvent );

                // 		lastPosition.copy( scope.object.position );
                // 		lastZoom = scope.object.zoom;

                // 	}

                // } else {

                // 	console.warn( 'THREE.TrackballControls: Unsupported camera type' );

                // }

            };

            this.reset = function () {

                _state = STATE.NONE;
                _keyState = STATE.NONE;

                scope.target.copy(scope.target0);
                scope.object.position.copy(scope.position0);
                scope.object.up.copy(scope.up0);
                scope.object.zoom = scope.zoom0;

                scope.object.updateProjectionMatrix();

                _eye.sub(scope.object.position, scope.target);

                scope.object.lookAt(scope.target);

                scope.dispatchEvent(_changeEvent);

                lastPosition.copy(scope.object.position);
                lastZoom = scope.object.zoom;

            };

            // listeners

            function onPointerDown(event) {

                if (scope.enabled === false) return;

                switch (event.pointerType) {

                    case 'mouse':
                    case 'pen':
                        onMouseDown(event);
                        break;

                    // TODO touch

                }

            }

            function onPointerMove(event) {

                if (scope.enabled === false) return;

                switch (event.pointerType) {

                    case 'mouse':
                    case 'pen':
                        onMouseMove(event);
                        break;

                    // TODO touch

                }

            }

            function onPointerUp(event) {

                if (scope.enabled === false) return;

                switch (event.pointerType) {

                    case 'mouse':
                    case 'pen':
                        onMouseUp(event);
                        break;

                    // TODO touch

                }

            }

            function keydown(event) {

                if (scope.enabled === false) return;

                window.removeEventListener('keydown', keydown);

                if (_keyState !== STATE.NONE) {

                    return;

                } else if (event.code === scope.keys[STATE.ROTATE] && !scope.noRotate) {

                    _keyState = STATE.ROTATE;

                } else if (event.code === scope.keys[STATE.ZOOM] && !scope.noZoom) {

                    _keyState = STATE.ZOOM;

                } else if (event.code === scope.keys[STATE.PAN] && !scope.noPan) {

                    _keyState = STATE.PAN;

                }

            }

            function keyup() {

                if (scope.enabled === false) return;

                _keyState = STATE.NONE;

                window.addEventListener('keydown', keydown);

            }

            function onMouseDown(event) {

                event.preventDefault();

                if (_state === STATE.NONE) {

                    switch (event.button) {

                        case scope.mouseButtons.LEFT:
                            if (is2D) _state = STATE.PAN;
                            else _state = STATE.ROTATE;
                            break;

                        case scope.mouseButtons.MIDDLE:
                            _state = STATE.ZOOM;
                            break;

                        case scope.mouseButtons.RIGHT:
                            _state = STATE.PAN;
                            break;

                        default:
                            _state = STATE.NONE;

                    }

                }

                const state = (_keyState !== STATE.NONE) ? _keyState : _state;

                if (state === STATE.ROTATE && !scope.noRotate) {

                    _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
                    _movePrev.copy(_moveCurr);

                } else if (state === STATE.ZOOM && !scope.noZoom) {

                    _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
                    _zoomEnd.copy(_zoomStart);

                } else if (state === STATE.PAN && !scope.noPan) {

                    _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
                    _panEnd.copy(_panStart);

                }

                scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);
                scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);

                scope.dispatchEvent(_startEvent);

            }

            function onMouseMove(event) {

                if (scope.enabled === false) return;

                event.preventDefault();

                const state = (_keyState !== STATE.NONE) ? _keyState : _state;

                if (state === STATE.ROTATE && !scope.noRotate) {

                    _movePrev.copy(_moveCurr);
                    _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));

                } else if (state === STATE.ZOOM && !scope.noZoom) {

                    _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));

                } else if (state === STATE.PAN && !scope.noPan) {

                    _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));

                }

            }

            function onMouseUp(event) {

                if (scope.enabled === false) return;

                event.preventDefault();

                _state = STATE.NONE;

                scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
                scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);

                scope.dispatchEvent(_endEvent);

            }

            function mousewheel(event) {

                if (scope.enabled === false) return;

                if (scope.noZoom === true) return;

                event.preventDefault();

                switch (event.deltaMode) {

                    case 2:
                        // Zoom in pages
                        _zoomStart.y -= event.deltaY * 0.025;
                        break;

                    case 1:
                        // Zoom in lines
                        _zoomStart.y -= event.deltaY * 0.01;
                        break;

                    default:
                        // undefined, 0, assume pixels
                        _zoomStart.y -= event.deltaY * 0.00025;
                        break;

                }

                scope.dispatchEvent(_startEvent);
                scope.dispatchEvent(_endEvent);

            }

            function touchstart(event) {

                if (scope.enabled === false) return;

                event.preventDefault();

                switch (event.touches.length) {

                    case 1:
                        if (is2D) {
                            _state = STATE.PAN;
                            _panStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
                            _panEnd.copy(_panStart);
                        }
                        else {
                            _state = STATE.TOUCH_ROTATE;
                            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
                            _movePrev.copy(_moveCurr);
                        }
                        break;

                    default: // 2 or more
                        _state = STATE.TOUCH_ZOOM_PAN;
                        const dx = event.touches[0].pageX - event.touches[1].pageX;
                        const dy = event.touches[0].pageY - event.touches[1].pageY;
                        _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

                        const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                        const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                        _panStart.copy(getMouseOnScreen(x, y));
                        _panEnd.copy(_panStart);
                        break;

                }

                scope.dispatchEvent(_startEvent);

            }

            function touchmove(event) {

                if (scope.enabled === false) return;

                event.preventDefault();

                switch (event.touches.length) {

                    case 1:
                        if (is2D) {
                            _panEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
                        }
                        else {
                            _movePrev.copy(_moveCurr);
                            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
                        }
                        break;

                    default: // 2 or more
                        const dx = event.touches[0].pageX - event.touches[1].pageX;
                        const dy = event.touches[0].pageY - event.touches[1].pageY;
                        _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

                        const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                        const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                        _panEnd.copy(getMouseOnScreen(x, y));
                        break;

                }

            }

            function touchend(event) {

                if (scope.enabled === false) return;

                switch (event.touches.length) {

                    case 0:
                        _state = STATE.NONE;
                        break;

                    case 1:
                        _state = STATE.TOUCH_ROTATE;
                        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
                        _movePrev.copy(_moveCurr);
                        break;

                }

                scope.dispatchEvent(_endEvent);

            }

            function contextmenu(event) {

                if (scope.enabled === false) return;

                event.preventDefault();

            }

            this.dispose = function () {

                scope.domElement.removeEventListener('contextmenu', contextmenu);

                scope.domElement.removeEventListener('pointerdown', onPointerDown);
                scope.domElement.removeEventListener('wheel', mousewheel);

                scope.domElement.removeEventListener('touchstart', touchstart);
                scope.domElement.removeEventListener('touchend', touchend);
                scope.domElement.removeEventListener('touchmove', touchmove);

                scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
                scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);

                window.removeEventListener('keydown', keydown);
                window.removeEventListener('keyup', keyup);

            };

            this.domElement.addEventListener('contextmenu', contextmenu);

            this.domElement.addEventListener('pointerdown', onPointerDown);
            this.domElement.addEventListener('wheel', mousewheel, { passive: false });

            this.domElement.addEventListener('touchstart', touchstart, { passive: false });
            this.domElement.addEventListener('touchend', touchend);
            this.domElement.addEventListener('touchmove', touchmove, { passive: false });

            this.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);
            this.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);

            window.addEventListener('keydown', keydown);
            window.addEventListener('keyup', keyup);

            this.handleResize();

            // force an update at start
            this.update();

        }

    }


    var shaderScripts = {
        "shader-particle-renderer-vs":
        {
            type: "x-shader/x-vertex",
            source: `#ifdef GL_ES
    precision mediump float;
    #endif
    attribute vec2 uv;

    uniform sampler2D sampler_particles;

    uniform vec2 viewSize;
    uniform vec4 scale;
    uniform vec4 color1;
    uniform vec2 clipX;
    uniform vec2 clipY;
    uniform vec2 clipZ;

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;

    uniform float fov;
    uniform vec3 camera;
    uniform float pointSizeMin;
    uniform float pointSizeMax;

    varying vec4 col;
    varying float alphaFactor;

    void main() {
        vec4 pos = texture2D(sampler_particles, uv);
        bool isVisible = clipX.x - 0.5 <= pos.x && pos.x <= clipX.y - 0.5 && clipY.x - 0.5 <= pos.y && pos.y <= clipY.y - 0.5 && clipZ.x - 0.5 <= pos.z && pos.z <= clipZ.y - 0.5;
        pos.xyz += -vec3(clipX.x + clipX.y, clipY.x + clipY.y, clipZ.x + clipZ.y)*0.5 + 0.5;
        pos.xyz *= scale.xyz;

        float distance = length(camera-(modelViewMatrix * pos).xyz);
        gl_PointSize = scale.w*fov/distance*viewSize.y/2048.;

        alphaFactor = 1.;
        if(gl_PointSize < 1.){
            alphaFactor = max(gl_PointSize, 1./16.);
        }

        col = color1;

        pos.w = 1.;
        gl_Position = projectionMatrix  * modelViewMatrix * pos;

        if(!isVisible){
            col.a = 0.;
        }}`
        },
        "shader-vs":
        {
            type: "x-shader/x-vertex",
            source: `#ifdef GL_ES
    precision mediump float;
    #endif
    attribute vec3 aPos;
    attribute vec2 aTexCoord;
    varying   vec2 uv;
    varying vec2 uv_orig;
    void main(void) {
            gl_Position = vec4(aPos, 1.);
            uv = aTexCoord;
            uv_orig = uv;
    }`
        },
        "shader-particle-renderer-fs":
        {
            type: "x-shader/x-fragment",
            source: `#ifdef GL_ES
    precision mediump float;
    #endif
    varying vec4 col;
    varying float alphaFactor;

    void main() {
        gl_FragColor = col;
        gl_FragColor.a *= alphaFactor;
    }`
        }
    }







    function getShader(gl, id) {
        var shaderScript = shaderScripts[id];
        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex")
            shader = gl.createShader(gl.VERTEX_SHADER);
        else
            return null;
        gl.shaderSource(shader, shaderScript.source);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
            api.showStatus("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
        return shader;
    }

    var gl;
    var ext;

    var prog_render_particles;

    var FBO_particles;

    // particle position buffer in a texture
    var texture_particles;

    var particlesWidth = 512;
    var particlesHeight = 512;

    var particleCount = 64 * 64 * 64;// can also be set to lower than particlesWidth * particlesHeight

    // main animation loop vars

    var sizeX = 1024; // texture size (must be powers of two, must also be greater than the particles texture *?*)
    var sizeY = 512;

    var viewX = sizeX; // viewport size (ideally exactly the texture size)
    var viewY = sizeY;

    var delay = 1 / 60;
    var it = 1; // main loop buffer toggle
    var frame = 0; // frame counter (to be resetted every 1000ms)
    var framecount = 0; // not resetted
    var fps;
    var time;
    var timer;
    var starttime = new Date().getTime();

    var particleBuffer;

    //Threejs setup
    var camera, scene, group, controls;
    var gui, scopeParams;

    var update_webgl_status_callback;
    var canvas;
    var ScopeParams = function () {
        this.scaleX = 1;
        this.scaleY = 1;
        this.scaleZ = 1;
        this.pointSize = 5;

        this.distance = 4.0;
        this.fov = 16.;
        this.pointSizeMin = 0;
        this.pointSizeMax = 12;
    }

    function onViewportChanged() {
        viewX = window.innerWidth;
        viewY = window.innerHeight;
        canvas.width = viewX;
        canvas.height = viewY;

        var angle = 75;
        var aspect = viewX / viewY;
        var near = .1;
        var far = 10000;

        camera = new THREE.PerspectiveCamera(angle, aspect, near, far);
        scene = new THREE.Scene();
        group = new THREE.Object3D();
        scene.add(camera);
        scene.add(group);
        camera.lookAt(group);

        // Camera projection matrix

        updateMatrices();

        controls = new TrackballControls(camera, canvas);

        group.position.set(0, 0, 0);

        camera.position.set(0, 0, scopeParams.distance);

        camera.fov = scopeParams.fov;
        camera.projectionMatrix = new THREE.Matrix4().makePerspective(camera.fov, window.innerWidth / window.innerHeight, camera.near, camera.far);

        controls.rotateSpeed = 5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.065;

        controls.dynamicDampingFactor = 0.2;
    }

    var rerender = false;
    function setRerender() {
        totalNumberOfChunks = 0;
        scopeParams['# of locs'] = 0;
        for (var i = 0; i < fileIDs.length; i++) {
            if (scopeParams['active ' + i] && scopeParams['alpha ' + i] > 0) {
                totalNumberOfChunks += files[fileIDs[i]].locations.numChunks;
                scopeParams['# of locs'] += files[fileIDs[i]].locations.rows;
            }
            var color = scopeParams['color ' + i];
            if (typeof (color) == "string") {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
                scopeParams['color ' + i] = [
                    parseInt(result[1], 16),
                    parseInt(result[2], 16),
                    parseInt(result[3], 16)
                ];
            }
        }
        rerender = true;
    }

    function initGUI() {
        // gui = new dat.GUI();
        gui = new dat.GUI({ autoPlace: false });
        scopeParams = new ScopeParams();
    }


    function load3DViewer(canvasElement, update_callback) {
        update_webgl_status_callback = update_callback || console.log;

        var customContainer = document.getElementById('gui-webgl');
        customContainer.appendChild(gui.domElement);
        scopeParams['# of locs'] = 0;
        scopeParams['reset scale'] = function () {
            scopeParams['x'] = 1;
            scopeParams['y'] = 1;
            scopeParams['z'] = 1;
            scopeParams['point size'] = 3;
            rerender = true;
        };

        scopeParams['reset scale']();
        var scaleFolder = gui.addFolder('Scale (x10)');
        scaleFolder.add(scopeParams, 'x', 0, 10).onChange(setRerender);
        scaleFolder.add(scopeParams, 'y', 0, 10).onChange(setRerender);
        scaleFolder.add(scopeParams, 'z', 0, 10).onChange(setRerender);
        scaleFolder.add(scopeParams, 'reset scale');

        scopeParams['reset clipping'] = function () {
            scopeParams['x min'] = 0;
            scopeParams['x max'] = 1;
            scopeParams['y min'] = 0;
            scopeParams['y max'] = 1;
            scopeParams['z min'] = 0;
            scopeParams['z max'] = 1;
            rerender = true;
        };
        scopeParams['reset clipping']();
        var clippingFolder = gui.addFolder('Clipping');
        clippingFolder.add(scopeParams, 'x min', 0, 1).onChange(setRerender);
        clippingFolder.add(scopeParams, 'x max', 0, 1).onChange(setRerender);
        clippingFolder.add(scopeParams, 'y min', 0, 1).onChange(setRerender);
        clippingFolder.add(scopeParams, 'y max', 0, 1).onChange(setRerender);
        if (!is2D) clippingFolder.add(scopeParams, 'z min', 0, 1).onChange(setRerender);
        if (!is2D) clippingFolder.add(scopeParams, 'z max', 0, 1).onChange(setRerender);
        clippingFolder.add(scopeParams, 'reset clipping');

        gui.add(scopeParams, '# of locs');
        gui.add(scopeParams, 'point size', 0, 50).onChange(setRerender);
        canvas = canvasElement; //document.getElementById("c");
        try {
            gl = canvas.getContext("webgl", { depth: false, preserveDrawingBuffer: true });
        } catch (e) {
        }
        if (!gl) {
            api.showStatus("Meh! Y u no support WebGL !?!");
            return;
        }

        ["OES_texture_float"].forEach(function (name) {
            console.log("check " + name);
            try {
                ext = gl.getExtension(name);
            } catch (e) {
                api.showStatus(e);
            }
            if (!ext) {
                api.showStatus("Meh! Y u no support " + name + " !?!");
                return;
            }
            ext = false;
        });

        if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
            api.showStatus("Meh! Y u no support vertex shader textures !?!");
            return;
        }


        files = [];
        fileIDs = [];

        document.addEventListener("orientationchange", window.onresize = onViewportChanged);
        window.addEventListener('DOMMouseScroll', mousewheel, false);
        window.addEventListener('mousewheel', mousewheel, false);

        onViewportChanged();

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());

        var d = 1 / 512;
        var locationCoordsBuffer = new ArrayBuffer(512 * 512 * 16);
        locationCoordsBuffer.float32 = new Float32Array(locationCoordsBuffer);
        for (var i = 0; i < 512; i++) {
            for (var j = 0; j < 512; j++) {
                locationCoordsBuffer.float32[(i * 512 + j) * 2 + 0] = d / 2 + j * d;
                locationCoordsBuffer.float32[(i * 512 + j) * 2 + 1] = d / 2 + i * d;
            }
        }
        var attributesBuffer = new ArrayBuffer(512 * 512 * 16);
        attributesBuffer.float32 = new Float32Array(attributesBuffer);

        FBO_particles = gl.createFramebuffer();
        texture_particles = createAndBindParticleTexture(attributesBuffer.float32, FBO_particles);

        var aParticleLoc = 1;
        prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

        gl.useProgram(prog_render_particles);
        gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);

        gl.enableVertexAttribArray(aParticleLoc);
        particleBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, locationCoordsBuffer.float32, gl.STATIC_DRAW);
        gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 8, 0);

        timer = setInterval(fr, 1000);
        time = new Date().getTime() - starttime;

        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.blendEquation(gl.FUNC_ADD);
        gl.clearColor(0, 0, 0, 1);

        anim();
    }

    function createAndLinkProgram(fsId) {
        var program = gl.createProgram();
        gl.attachShader(program, getShader(gl, "shader-vs"));
        gl.attachShader(program, getShader(gl, fsId));
        gl.linkProgram(program);
        return program;
    }

    function createAndLinkParticleRenderer(aParticleLoc) {
        var program = gl.createProgram();
        gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
        gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs"));
        gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
        gl.linkProgram(program);
        return program;
    }

    function createAndBindTexture(glPixels, scale, fbo, filter) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, gl.FLOAT, glPixels);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        checkFrameBuffer();
        return texture;
    }

    function createAndBindParticleTexture(glPixels, fbo) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, glPixels);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        checkFrameBuffer();
        return texture;
    }

    var newLocations = false;
    function onlocations() {
        newLocations = true;
    }

    function loadNewLocationTextures() {
        if (newLocations) {
            // assume only one file has been loaded and it's the last in the list of IDs
            var locations = files[fileIDs[fileIDs.length - 1]].locations;
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, texture_particles);
            gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_particles);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, locations.stridedFloat32Arrays[1]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_particles, 0);

            setRerender();
        }
    }

    function checkFrameBuffer() {
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status != gl.FRAMEBUFFER_COMPLETE) {
            console.log("Framebuffer, y u not completed yet!?");
            for (var i in gl) {
                if (typeof (gl[i]) == "number" && gl[i] == status) {
                    console.log("-> " + i);
                }
            }
        }
    }

    function setUniforms(program) {
        gl.uniform2f(gl.getUniformLocation(program, "viewSize"), viewX, viewY);

        gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));

        gl.uniform4f(gl.getUniformLocation(program, "scale"), scopeParams['x'], scopeParams['y'], scopeParams['z'], scopeParams['point size']);

        var minX = Math.min(scopeParams['x min'], scopeParams['x max']);
        var maxX = Math.max(scopeParams['x min'], scopeParams['x max']);
        gl.uniform2f(gl.getUniformLocation(program, "clipX"), minX, maxX);

        var minY = Math.min(scopeParams['y min'], scopeParams['y max']);
        var maxY = Math.max(scopeParams['y min'], scopeParams['y max']);
        gl.uniform2f(gl.getUniformLocation(program, "clipY"), minY, maxY);

        var minZ = Math.min(scopeParams['z min'], scopeParams['z max']);
        var maxZ = Math.max(scopeParams['z min'], scopeParams['z max']);
        gl.uniform2f(gl.getUniformLocation(program, "clipZ"), minZ, maxZ);

        gl.uniform1f(gl.getUniformLocation(program, "fov"), 1. / Math.tan(scopeParams.fov / 180 * Math.PI));
        gl.uniform3f(gl.getUniformLocation(program, "camera"), 0, 0, scopeParams.distance);

        gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 1);
    }

    var oldProjectionMatrixArray = new Float32Array(16);
    var oldFov = 0;
    var oldViewMatrixArray = new Float32Array(16);
    var isStill = true; var wasStill = true;

    function anim(t) {
        wasStill = isStill;
        isStill = true;
        for (var i = 0; i < 16; i++) {
            isStill = isStill &&
                oldProjectionMatrixArray[i] - camera._projectionMatrixArray[i] == 0 &&
                oldViewMatrixArray[i] - camera._viewMatrixArray[i] == 0;
        }
        isStill = isStill && camera.fov == oldFov
        if (!isStill) {
            oldFov = camera.fov;
            oldProjectionMatrixArray.set(camera._projectionMatrixArray);
            oldViewMatrixArray.set(camera._viewMatrixArray);
        }

        loadNewLocationTextures();

        controls.update();
        updateMatrices();

        renderParticles();

        if (t)
            throttle(t);

        requestAnimationFrame(anim);

        newLocations = false;

        frame++;
        framecount++;
    }

    var totalNumberOfChunks = 0;
    var chunksPerAnimationFrame = 0;
    var lastChunkRendered = -1;
    var targetFps = 24;
    var lastRenderTime = 0;

    function throttle(t) {
        var dt = t - lastRenderTime;
        lastRenderTime = t;
        if (isStill) {
            return;
        }
        if (dt < 1000 / targetFps) {
            chunksPerAnimationFrame += 0.25;
        } else {
            chunksPerAnimationFrame -= 0.25;
        }
        chunksPerAnimationFrame = Math.max(chunksPerAnimationFrame, 0);
        chunksPerAnimationFrame = Math.min(chunksPerAnimationFrame, totalNumberOfChunks);
    }

    function renderParticles() {
        gl.viewport(0, 0, viewX, viewY);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        var newMove = wasStill && !isStill;
        if (rerender || !isStill || newLocations) {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.flush();
            lastChunkRendered = -1;
        }
        if (isStill && lastChunkRendered == -1 && !newLocations && !rerender || totalNumberOfChunks == 0) {
            rerender = false;
            return;
        }
        rerender = false;

        gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
        gl.useProgram(prog_render_particles);
        setUniforms(prog_render_particles);

        gl.uniformMatrix4fv(gl.getUniformLocation(prog_render_particles, "projectionMatrix"), false, camera._projectionMatrixArray);
        gl.uniformMatrix4fv(gl.getUniformLocation(prog_render_particles, "modelViewMatrix"), false, camera._viewMatrixArray);

        gl.enable(gl.BLEND);

        gl.activeTexture(gl.TEXTURE1);
        var chunk = 0;
        loopFiles:
        for (var i = 0; i < fileIDs.length; i++) {
            var file = files[fileIDs[i]];
            var lastChunk = file.locations.numChunks - 1;
            var color = scopeParams['color ' + i];
            var alpha = scopeParams['alpha ' + i];
            var active = scopeParams['active ' + i] && alpha > 0;
            if (!active) {
                continue loopFiles; // skip the chunks of this file
            }
            gl.uniform4f(gl.getUniformLocation(prog_render_particles, "color1"), color[0] / 255, color[1] / 255, color[2] / 255, alpha);
            for (var j = 0; j < file.locations.numChunks; j++) {
                if (chunk > lastChunkRendered) {
                    if (chunk <= lastChunkRendered + chunksPerAnimationFrame && chunk < totalNumberOfChunks) {
                        var locationTexture = file.locations.textures[j];
                        gl.bindTexture(gl.TEXTURE_2D, locationTexture);
                        var pointCount = file.locations.bufferLength;
                        if (j == lastChunk) {
                            pointCount = file.locations.rows - file.locations.bufferLength * lastChunk
                            lastChunkRendered = -1;
                        }
                        gl.drawArrays(gl.POINTS, 0, pointCount);
                    } else {
                        lastChunkRendered = chunk - 1;
                        break loopFiles; // get out of both for loops
                    }
                }
                chunk++;
            }
        }
        gl.disable(gl.BLEND);
        gl.flush();
    }

    function updateMatrices() {
        scene.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);

        if (!camera._viewMatrixArray)
            camera._viewMatrixArray = new Float32Array(16);
        camera.matrixWorldInverse.flattenToArray(camera._viewMatrixArray);

        if (!camera._projectionMatrixArray)
            camera._projectionMatrixArray = new Float32Array(16);
        camera.projectionMatrix.flattenToArray(camera._projectionMatrixArray);

        if (!group.__webglInit) {
            group._modelViewMatrix = new THREE.Matrix4();
            group._objectMatrixArray = new Float32Array(16);
            group._modelViewMatrixArray = new Float32Array(16);
        }

        group.matrixWorld.flattenToArray(group._objectMatrixArray);
        group._modelViewMatrix.multiplyToArray(camera.matrixWorldInverse, group.matrixWorld, group._modelViewMatrixArray);
    }

    var colors = [
        [255, 28, 14],
        [255, 0, 255],
        [0, 255, 255],
        [0, 255, 0],
        [0, 0, 255],
        [255, 255, 0],
    ];

    var files = [];
    var fileIDs = [];
    function createFileID(file) {
        if (file.hash && file.hash.length > 5) return file.hash
        else return file.name + '.' + file.size;
    }
    function gotFile(file) {
        return fileIDs.indexOf(createFileID(file)) > -1;
    }
    function addFile(file) {
        var fileID = createFileID(file);
        files[fileID] = file;
        fileIDs.push(fileID);
    }

    function show3DLocalizations(options, update_status_callback) {
        let bufferLength = (512 * 512); // defaulting to 2M
        const before = Date.now();
        const strideTitles = ["x", "y", "z"]
        const stridedArrayBuffers = [];
        const stridedFloat32Arrays = [];
        const float32Arrays = options.tableDict;
        if (options.mode) is2D = options.mode === '2D'
        else {
            if (!float32Arrays.z) is2D = true;
            else
                is2D = false;
        }
        const isFiltered = options.isFiltered;
        if (!isFiltered) options.filteredRows = options.rows;
        const numChunks = Math.ceil(options.filteredRows / bufferLength);
        for (var chunkIndex = 0; chunkIndex < numChunks; chunkIndex++) {
            stridedArrayBuffers[chunkIndex] = new ArrayBuffer(bufferLength * 16); // 4x4 for four float32 values of four bytes for the values for the given stride indices
            stridedFloat32Arrays[chunkIndex] = new Float32Array(stridedArrayBuffers[chunkIndex]);
        }
        const normalization = {
            scale: Math.max(
                (options.max[strideTitles[0]] - options.min[strideTitles[0]]),
                (options.max[strideTitles[1]] - options.min[strideTitles[1]]),
                is2D ? 0 : (options.max[strideTitles[2]] - options.min[strideTitles[2]])
            ),
            offsetX: (options.max[strideTitles[0]] - options.min[strideTitles[0]]) / 2,//options.avg[strideTitles[0]],
            offsetY: (options.max[strideTitles[1]] - options.min[strideTitles[1]]) / 2,//options.avg[strideTitles[1]],
            offsetZ: is2D ? 0 : (options.max[strideTitles[2]] - options.min[strideTitles[2]]) / 2,//options.avg[strideTitles[2]],
            offsetT: 0,//options.avg[strideTitles[3]],
        }
        if (update_status_callback)
            update_status_callback({ rendering: true, rendering_progress: 0, rendering_status: "normalize into strided array chunks" })

        let progress = -1;
        let filteredLine = 0;
        for (var line = 0; line < options.rows; line++) {
            var newProgress = Math.floor(100 * line / (options.rows + 1));
            if (newProgress != progress) {
                progress = newProgress;
                if (update_status_callback)
                    update_status_callback({ rendering_progress: progress })
            }
            if (isFiltered && !isFiltered[line]) continue
            var chunkIndex = Math.floor(filteredLine / bufferLength);
            var chunkLine = filteredLine - chunkIndex * bufferLength;
            var stridedFloat32Array = stridedFloat32Arrays[chunkIndex];

            stridedFloat32Array[chunkLine * 4 + 0] = (float32Arrays[strideTitles[0]][line] - normalization.offsetX) / normalization.scale;
            stridedFloat32Array[chunkLine * 4 + 1] = (float32Arrays[strideTitles[1]][line] - normalization.offsetY) / normalization.scale;
            stridedFloat32Array[chunkLine * 4 + 2] = is2D ? 0 : (float32Arrays[strideTitles[2]][line] - normalization.offsetZ) / normalization.scale;
            stridedFloat32Array[chunkLine * 4 + 3] = 1;//(float32Arrays[strideTitles[3]][line]-normalization.offsetT)/normalization.scale;
            filteredLine += 1;
        }
        if (update_status_callback)
            update_status_callback({ rendering_status: "normalize into strided array chunks [ms]: " + (Date.now() - before) })
        const locations = { file_hash: options.file_hash, filteredRows: options.filteredRows, file_name: options.file_name, file_size: options.file_size, bufferLength: bufferLength, numChunks: numChunks, rows: options.rows, headers: options.headers, stridedArrayBuffers: stridedArrayBuffers }
        console.log("normalize into strided array chunks [ms]: " + (Date.now() - before), locations);
        render3DLocalizations(locations)
        if (update_status_callback)
            update_status_callback({ rendering_status: "3D view rendered(loc.:" + options.filteredRows + ", file:" + options.file_name + ").", rendering_progress: 100, rendering: false })
    }

    function render3DLocalizations(locations) {
        if (locations) {
            var file = { hash: locations.file_hash, name: locations.file_name, size: locations.file_size }
            var fileid = createFileID(file)
            var indx = fileIDs.indexOf(fileid)
            if (indx >= 0) {
                file = files[fileid]
            }
            locations.stridedFloat32Arrays = [];
            locations.textures = [];
            for (var chunk = 0; chunk < locations.numChunks; chunk++) {
                locations.stridedFloat32Arrays[chunk] = new Float32Array(locations.stridedArrayBuffers[chunk]);
                locations.textures[chunk] = createAndBindParticleTexture(locations.stridedFloat32Arrays[chunk], FBO_particles);
            }
            console.log(files)
            file.locations = locations;

            totalNumberOfChunks += locations.numChunks;

            if (indx >= 0) {
                onlocations();
            }
            else {
                addFile(file);
                onlocations();
                var colorIndex = fileIDs.length % colors.length;
                if (locations.numChunks > 0) {
                    var colorFolder = gui.addFolder(locations.file_name + ' (#' + locations.filteredRows + ')');
                    var N = fileIDs.indexOf(fileid);
                    var activN = 'active ' + N;
                    var colorN = 'color ' + N;
                    var alphaN = 'alpha ' + N;
                    scopeParams[activN] = true;
                    scopeParams[colorN] = fileIDs.length === 1 ? colors[0] : colors[colorIndex];
                    scopeParams[alphaN] = 0.85;
                    colorFolder.add(scopeParams, activN).onChange(setRerender);
                    colorFolder.addColor(scopeParams, colorN).onChange(setRerender);
                    colorFolder.add(scopeParams, alphaN, 0, 1).onChange(setRerender);
                    colorFolder.open();
                }
                console.log(files, fileIDs);
                console.log("locations uploaded to WebGL textures:");
                console.log(locations);
            }

            chunksPerAnimationFrame = totalNumberOfChunks; // this will throttle down quickly enough
        } else {
            console.log("something went wrong");
        }
    }

    function fr() { // updates every second
        scopeParams.Fps = frame;
        gui.__controllers[0].updateDisplay();
        // document.getElementById("fps").textContent = isStill ? 0 : frame;
        // document.getElementById("ppf").textContent = isStill ? 0 : Math.floor(chunksPerAnimationFrame) + " x 256k";
        if (update_webgl_status_callback)
            update_webgl_status_callback({ fps: isStill ? 0 : frame, ppf: isStill ? 0 : Math.floor(chunksPerAnimationFrame) + " x 256k" })
        frame = 0; // reset the frame counter
    }

    function mousewheel(event) {
        if (event.target != canvas) return;
        event.preventDefault();
        event.stopPropagation();

        var fovMAX = 130;
        var fovMIN = 1;

        camera.fov -= event.wheelDeltaY * 0.0033;
        camera.fov = Math.max(Math.min(camera.fov, fovMAX), fovMIN);
        camera.projectionMatrix = new THREE.Matrix4().makePerspective(camera.fov, window.innerWidth / window.innerHeight, camera.near, camera.far);

        scopeParams.fov = camera.fov;
    }

    function showExportCSV(smlm){
        scopeParams['Export']= "Select a format"
        const formats = [
            "Select a format",
            'ThunderSTORM (csv)',
            'ThunderSTORM (xls)'
        ]
        gui.add(scopeParams, 'Export', formats).listen().onChange(async () => {
            if(scopeParams['Export'] !== 'Select a format'){
                try{
                    await smlm.saveAs(scopeParams['Export'])
                }
                catch(e){
                    throw e
                }
                finally{
                    scopeParams['Export']= "Select a format"
                }
            }
        })
    }
    class ImJoyPlugin {
        async setup() {
        }

        getViewConfig() {
            const config = {};
            for (let k of Object.keys(scopeParams)) {
                if (typeof scopeParams[k] !== 'function') {
                    config[k] = scopeParams[k]
                }
            }
            return config;
        }

        captureImage() {
            const canvas = document.getElementById("histogram_canvas_3d");
            return canvas.toDataURL();
        }

        async show(fileInfo) {
            show3DLocalizations(fileInfo.data);
        }

        async run(ctx) {
            initGUI();
            if (ctx.config && ctx.config.samples) {
                // scopeParams.File = ctx.config.samples[0].files[0].download_url;
                const initFiles = ctx.config.samples[0].files
                scopeParams['File'] = initFiles.filter(
                    file =>
                    (file.name.endsWith('.smlm')||
                    file.name.endsWith('.csv')||
                    file.name.endsWith('.tsv')||
                    file.name.endsWith('.xls')||
                    file.name.endsWith('.txt'))
                    )[0].download_url;
                const options = {}
                for(let sample of ctx.config.samples)
                for (let f of sample.files) {
                    options[sample.name + '/' + f.name] = f.download_url;
                }
                const smlmPlugin = await api.getPlugin("SMLM File IO");
                gui.add(scopeParams, 'File', options).listen().onChange(async () => {
                    try {
                        const data = await smlmPlugin.load(scopeParams['File'])
                        for(let file of data.files){
                            await this.show(file)
                        }
                        showExportCSV(data)
                    }
                    catch (e) {
                        api.showMessage(`Failed to load file: ${e}`)
                    }
                });
                await load3DViewer(document.getElementById("histogram_canvas_3d"));
                try {

                    const data = await smlmPlugin.load(scopeParams['File'])
                    for(let file of data.files){
                        await this.show(file)
                    }
                    showExportCSV(data)
                }
                catch (e) {
                    api.showMessage(`Failed to load file: ${e}`)
                }
            }
            else if (ctx.data && (ctx.data.tableDict || Array.isArray(ctx.data))) {
                await load3DViewer(document.getElementById("histogram_canvas_3d"));
                if (ctx.data && ctx.data.tableDict)
                    await this.show(ctx.data);
                else if (ctx.data && Array.isArray(ctx.data)) {
     
                    for(let file of ctx.data){
                            await this.show(file)
                        }
                }
            }
            else{
                const smlmPlugin = await api.getPlugin("SMLM File IO");
                scopeParams['Load file'] = () => {
                    const fileElem = document.getElementById('myLocalFile');
                    fileElem.onchange = async () => {
                        try {
                            if (fileElem.files[0]) {
                                const data = await smlmPlugin.load(fileElem.files[0])
                                for(let file of data.files){
                                    await this.show(file)
                                }
                                showExportCSV(data)
                            }
                        }
                        catch (e) {
                            api.showMessage(`Failed to load file: ${e}`)
                        }
                    }
                    document.getElementById('myLocalFile').click();
                }
                gui.add(scopeParams, 'Load file')
                await load3DViewer(document.getElementById("histogram_canvas_3d"));
            }
        }
    }

    api.export(new ImJoyPlugin())
</script>

<window lang="html">
    <div>
        <div id="gui-webgl"> </div>
        <input id="myLocalFile" type="file" style="display:none" />
        <canvas id="histogram_canvas_3d"></canvas>
    </div>

</window>

<style lang="css">
    render-info {
        z-index: 20;
        text-align: right;
        color: #de199e;
        position: absolute;
        top: 8px;
        right: 45px;
        margin-top: 8px;
    }

    #histogram_canvas_3d {
        z-index: 13;
        position: relative;
        top: 0;
        left: 0;
    }

    #gui-webgl {
        z-index: 14;
        position: fixed;

    }

    body {
        margin: 0;
    }

    .title {
        width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
</style>