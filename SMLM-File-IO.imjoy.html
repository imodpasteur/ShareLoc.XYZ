<config lang="json">
    {
    "name": "SMLM File IO",
    "type": "web-worker",
    "version": "0.1.3",
    "api_version": "0.1.8",
    "description": "A plugin for loading and exporting SMLM images.",
    "ui": "",
    "tags": [],
    "inputs": null,
    "outputs": null,
    "icon": "ðŸ™€",
    "requirements":
    ["https://cdn.rawgit.com/Stuk/jszip/9fb481ac/dist/jszip.min.js","https://cdn.rawgit.com/satazor/js-spark-md5/bbd1624a/spark-md5.min.js", "https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.2/axios.min.js"],
    "dependencies": []
    }
</config>
<script lang="javascript">

    function randId() {
        return Math.random().toString(36).substr(2, 10);
    }

    /**
     * Copyright 2016-2017 Felix Woitzel. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    function parseFile(file, reading_callback, finish_callback) {
        var fileSize = file.size;
        var chunkSize = 104857600; //100 mega bytes
        var offset = 0;
        var self = this; // we need a reference to the current object
        var chunkReaderBlock = null;
        if (!file) {
            finish_callback(false)
            return
        }
        var readEventHandler = function (evt) {
            if (evt.target.error == null) {
                offset += evt.target.result.length;
                reading_callback(evt.target.result); // callback for handling read chunk
            } else {
                console.log("Read error: " + evt.target.error);
                finish_callback(false);
                return;
            }
            if (offset >= fileSize) {
                finish_callback(true);
                console.log("Done reading file");
                return;
            }
            // of to the next chunk
            chunkReaderBlock(offset, chunkSize, file);
        }
        chunkReaderBlock = function (_offset, length, _file) {
            var r = new FileReader();
            var blob = _file.slice(_offset, length + _offset);
            r.onload = readEventHandler;
            r.onerror = function () { finish_callback(false) }
            r.readAsText(blob);
        }
        // now let's start the read with the first block
        chunkReaderBlock(offset, chunkSize, file);
    }

    async function readTextFile(data, callback) {
        var format = data.format

        try {
            console.assert(format.type == 'table')
            console.assert(format.mode == 'text')
            console.assert(format.delimiter)
        } catch (e) {
            console.error(e)
            callback({ error: 'format error' });
            return
        }

        var delimiter = format.delimiter
        var headers = [];
        var transformedHeaders = [];
        var reader = new FileReader();


        var table_data = {};
        var arrayBuffersList = []
        var statshtml = "";
        var leftover_str = null;
        var min = [], max = [], avg = [];
        var rows = 0;
        var localization_num = 0;
        var before = Date.now();
        var file = data.file;
        var totalBytes = file.size;
        var bytesRead = 0;
        var val;
        table_data.file_name = file.name
        table_data.file_size = file.size
        table_data.file_type = file.type
        // table_data.arrayBuffersList = arrayBuffersList;
        // table_data.file = data.file;
        var isFirstBlock = true;
        const originalHeaders  = [];
        var reading_callback = function (result) {
            var arrayBuffers = [];
            var float32Arrays = [];
            if (leftover_str) {
                result = leftover_str + result;
            }
            var lines = result.split('\n');
            if (isFirstBlock) {

                if (format.header_row >= 0) {
                    if (format.header_transform['*all*']) {
                        var regex = new RegExp(format.header_transform['*all*'], "g")// /identifier="([\w\d\-_]+)"/g;
                        var match = regex.exec(lines[0]);
                        var ids = []
                        while (match != null) {
                            ids.push(match[1])
                            match = regex.exec(lines[0]);
                        }
                        lines[0] = ids.join(delimiter)
                    }
                    headers = lines[0].split(delimiter)
                    table_data.header_line = lines[0];
                    lines.shift();
                }
                else {
                    table_data.header_line = null
                    const num = lines[0].split(delimiter).length
                    headers = []
                    for (var header = 0; header < num; header++) {
                        headers.push(header.toString())
                    }
                }

                for (var header = 0; header < headers.length; header++) {
                    var escapedTitle = headers[header].toString().replace(/'/g, '').replace(/"/g, '');
                    originalHeaders[header] = headers[header].toString();
                    if (format.header_transform[escapedTitle]) {
                        transformedHeaders[header] = format.header_transform[escapedTitle].replace(/[^a-zA-Z0-9]+/g, '_').trim()
                    }
                    else {
                        transformedHeaders[header] = escapedTitle.replace(/[^a-zA-Z0-9]+/g, '_').trim()
                    }
                    if (transformedHeaders[header].startsWith('_')) {
                        transformedHeaders[header] = transformedHeaders[header].slice(1)
                    }
                    min[header] = Number.POSITIVE_INFINITY;
                    max[header] = Number.NEGATIVE_INFINITY;
                    avg[header] = 0;
                }
                isFirstBlock = false;
                table_data.headers = transformedHeaders;
                if (transformedHeaders.indexOf('x') < 0 || !transformedHeaders.indexOf('y') < 0) {
                    callback({ error: 'wrong file format' });
                    return
                }
            }
            var endsWithNewLine = (lines[lines.length - 1] != "");
            var lineNum = lines.length - (endsWithNewLine ? 1 : 0);

            if (endsWithNewLine) {
                leftover_str = lines[lines.length - 1];
            }
            else {
                leftover_str = null;
            }
            for (var header = 0; header < headers.length; header++) {
                arrayBuffers[header] = new ArrayBuffer(lineNum * 4);
                float32Arrays[header] = new Float32Array(arrayBuffers[header]);
            }
            var skipped = 0
            for (var line = 0; line < lineNum; line++) {
                localization_num += 1;
                bytesRead += lines[line].length
                if (localization_num % 100000 == 0) {
                    callback({ progress: bytesRead / totalBytes * 100, localization_num: localization_num });
                }
                val = lines[line].split(delimiter);
                if (lines[line] == '' || headers.length != val.length) {
                    skipped++
                    continue
                }
                for (var header = 0; header < headers.length; header++) {
                    var v = Number(val[header]);
                    if (min[header] > v) {
                        min[header] = v;
                    }
                    if (max[header] < v) {
                        max[header] = v;
                    }
                    if (avg[header] == undefined) {
                        avg[header] = 0;
                    }
                    avg[header] += v;
                    float32Arrays[header][line - skipped] = v;
                }
            }
            if (skipped) console.log('skipped ' + skipped + ' lines.')
            for (var header = 0; header < headers.length; header++) {
                arrayBuffers[header] = arrayBuffers[header].slice(0, arrayBuffers[header].byteLength - skipped * 4)
                float32Arrays[header] = float32Arrays[header].slice(0, float32Arrays[header].length - skipped)
            }
            rows += (lineNum - skipped);
            arrayBuffersList.push(arrayBuffers)
        };

        var finish_callback = function (sucess) {
            if (!sucess) {
                console.log('finished with error')
                callback({ error: 'loading error' });
                return
            }
            isFirstBlock = true
            var float32Arrays = [];
            var tableUint8Arrays = []
            var dd = new Float32Array(arrayBuffersList[0][1]);
            for (var header = 0; header < headers.length; header++) {
                var arrayUint8 = new Uint8Array(rows * 4);
                var offset = 0;
                for (var i = 0; i < arrayBuffersList.length; i++) {
                    arrayUint8.set(new Uint8Array(arrayBuffersList[i][header]), offset);
                    offset += arrayBuffersList[i][header].byteLength
                }
                tableUint8Arrays[header] = new Uint8Array(arrayUint8.buffer);
                float32Arrays[header] = new Float32Array(arrayUint8.buffer);
            }
            table_data.tableArrays = float32Arrays;
            table_data.tableUint8Arrays = tableUint8Arrays;
            statshtml = rows + " samples loaded; ";
            for (var header = 0; header < transformedHeaders.length; header++) {
                avg[header] = avg[header] / rows
                statshtml += transformedHeaders[header] + ": "
                    + min[header] + " - " + max[header] + " ("
                    + Math.round(avg[header] * 10) / 10 + "), ";
            }
            statshtml += "parsing time [ms]: " + (Date.now() - before);
            table_data.statshtml = statshtml
            table_data.rows = rows
            table_data.columns = float32Arrays.length

            table_data.min = {}
            table_data.max = {}
            table_data.avg = {}
            table_data.tableDict = {}
            table_data.tableUint8Dict = {}
            var transferables = []
            for (let i = 0; i < transformedHeaders.length; i++) {
                table_data.min[transformedHeaders[i]] = min[i]
                table_data.max[transformedHeaders[i]] = max[i]
                table_data.avg[transformedHeaders[i]] = avg[i]
                table_data.tableDict[transformedHeaders[i]] = float32Arrays[i]
                transferables.push(float32Arrays[i].buffer)
                table_data.tableUint8Dict[transformedHeaders[i]] = tableUint8Arrays[i]
            }
            table_data.loaded = true
            table_data.original_config = {
                headers: originalHeaders,
                delimiter: delimiter,
                file_name: data.file.name
            }
            callback(table_data, transferables);
        }
        
        parseFile(data.file, reading_callback, finish_callback)
    }


    function exportToFile(data, callback) {
        try {
            console.log('rendering worker is running...')
            const headers = data.headers;
            const delimiter = data.delimiter;
            const tableDict = data.tableDict;
            const format = data.format;
            let content = ""
            for (let header of headers) {
                content = content + header + delimiter
            }

            content = content.slice(0, content.length - 1) + '\n'
            callback({ progress: 0 });
            const rows = tableDict[headers[0]].length
            for (let i = 0; i < rows; i++) {
                for (let header of headers) {
                    content = content + tableDict[header][i].toPrecision(3) + delimiter
                }
                content = content.slice(0, content.length - 1) + '\n'

                if (i % 1000 === 0) callback({ progress: i / rows * 100 });
            }
            const file = new File([content], data.filename + '.' + format, {
                type: "text/plain",
            })
            callback({ finished: true, file });
        } catch (e) {
            console.error(e)
            callback({ error: e, message: 'something went wrong during rendering.', _options: options }, transferables);
        }
    }

    class smlmFile {
        constructor(file) {
            this.manifest = JSON.parse(JSON.stringify(manifest_template))
            this.formats = this.manifest.formats
            this.files = this.manifest.files
            this.channels = {}
            this.zipFile = null
            this.uploaded = false
            this.isSMLM = false
            this.manifest.license = this.manifest.license || 'CC BY 4.0'
            this.manifest.tags = this.manifest.tags || []
            this.manifest.citeAs = this.manifest.citeAs || ''
        }
        import_image(file, image_format, info, is_append, update_callback) {
            return new Promise((resolve, reject) => {
                console.log('import file', image_format)
                var FR = new FileReader();
                FR.onload = (e) => {
                    var img = new Image();
                    img.addEventListener("load", () => {
                        const file_info = {}
                        file_info.format = image_format

                        file_info.type = "image"
                        file_info.size = [img.height, img.width]
                        Object.assign(file_info, info)
                        const data = {}
                        data.image = img
                        data.file = file
                        data.name = file.name
                        data.file_name = file.name
                        data.file_size = file.size
                        file_info.name = file.name
                        file_info.data = data
                        const hash = this.calculate_hash(file_info)
                        file_info.hash = hash
                        file_info.tags = info.tags || []
                        file_info.pixel_size = info.pixel_size
                        data.file_hash = hash

                        if (is_append || !this.files || this.files.length == 0) {
                            // append to this file
                            this.files.push(file_info)
                        }
                        else {
                            // reset files
                            this.manifest = JSON.parse(JSON.stringify(manifest_template))
                            this.formats = this.manifest.formats
                            this.files = this.manifest.files
                            this.files.push(file_info)
                        }

                        this.formats[image_format] = supported_image_formats[image_format]
                        if (!this.manifest.name || this.manifest.name == "") {
                            if (this.isSMLM) {
                                this.manifest.name = file.name.split(".")[0] + ".smlm"
                            }
                            else {
                                this.manifest.name = file.name.split(".")[0] + ".zip"
                            }

                        }
                        if (!this.manifest.hash)
                            this.update_hash()
                        info.channel = info.channel || 'default'
                        this.channels[info.channel] = this.channels[info.channel] || []
                        this.channels[info.channel].push(data)
                        this.zipFile = null
                        this.uploaded = false
                        console.log(data)
                        resolve(file_info)
                        //context.drawImage(img, 0, 0);
                    });
                    img.src = e.target.result;
                };
                FR.onerror = (e) => {
                    reject(e)
                }
                FR.readAsDataURL(file);
            })
        }
        import_text_table(file, table_format, info, is_append, update_callback) {
            console.log(table_format)
            if (typeof table_format === 'string' || table_format instanceof String) {
                table_format = supported_text_formats[table_format]
            }
            return new Promise((resolve, reject) => {
                if (!table_format) {
                    console.log("no table format not found.", table_format)
                    reject("no table format not found.")
                    return
                }

                console.log('loading...')
                update_callback({ running: true, running_status: `Loading ${file.name.slice(0, 32)}...` })

                const callback = (data) => {
                    if (data.error) {
                        reject(data.error)
                    }
                    else if (data.loaded) {
                        // this.file_loaded = true
                        console.log(data.tableDict)
                        console.log('done', data.statshtml, data)
                        const file_info = JSON.parse(JSON.stringify(file_info_template))

                        data.name = file.name
                        data.file_size = file.size
                        file_info.name = file.name
                        file_info.type = "table"
                        file_info.rows = data.rows
                        file_info.min = data.min
                        file_info.max = data.max
                        file_info.avg = data.avg
                        file_info.offset = { "x": 0, "y": 0 }
                        file_info.data = data
                        const hash = this.calculate_hash(file_info)
                        file_info.hash = hash
                        data.file_hash = hash
                        file_info.tags = info.tags || []
                        file_info.pixel_size = info.pixel_size
                        if (is_append) {
                            // append to this file
                            this.files.push(file_info)
                        }
                        else {
                            // reset files
                            this.manifest = JSON.parse(JSON.stringify(manifest_template))
                            this.formats = this.manifest.formats
                            this.files = this.manifest.files
                            this.files.push(file_info)
                        }
                        if (!this.manifest.name || this.manifest.name == "") {
                            this.manifest.name = file.name.split(".")[0] + ".smlm"
                        }
                        if (!this.manifest.hash)
                            this.update_hash()
                        info.channel = info.channel || 'default'
                        this.channels[info.channel] = this.channels[info.channel] || []
                        this.channels[info.channel].push(data)
                        // this.formats[table_format.name] = table_format
                        this.zipFile = null
                        this.uploaded = false
                        // only files with a table can count as smlm
                        this.isSMLM = true
                        console.log(data)
                        resolve(file_info)
                    }
                    else if (data.progress) {
                        update_callback({ running_progress: data.progress, running_status: (data.localization_num / 1000000).toFixed(1) + 'M localizations loaded' })
                    }
                }
                readTextFile({ file: file, format: table_format }, callback)
            });
        }
        import_smlm(file, is_append, update_callback) {
            // TODO: support append
            if (is_append) {
                throw "please load smlm file first, append mode is not supported yet."
            }
            return new Promise((resolve, reject) => {
                JSZip.loadAsync(file)
                    .then((zip) => {
                        update_callback({ running: true })
                        const manifest_file = zip.file("manifest.json")
                        if (!manifest_file) {
                            reject('manifest.json is not present in the zip file')
                            return
                        }

                        manifest_file.async("string")
                            .then((meta_json) => {
                                const manifest = JSON.parse(meta_json)
                                const format_version = manifest.format_version
                                update_callback({ running_status: 'Manifest file loaded.' })
                                
                                const load_files = async () => {
                                    //TODO: render the files with a different async loader
                                    for (let file_no = 0; file_no < manifest.files.length; file_no++) {
                                        await new Promise((resolve2, reject2) => {
                                            const data = {}
                                            const file_info = manifest.files[file_no]
                                            if (file_info.type == "table") {
                                                update_callback({ running_status: 'Loading smlm file...' })
                                                const table_file = zip.file(file_info.name)
                                                const format_key = file_info.format
                                                update_callback({ running_status: 'Uncompressing file: ' + file_info.name })
                                                if (!table_file && manifest.formats[format_key]) {
                                                    reject2('table file ' + manifest.table_file + ' is not present in the zip file')
                                                    return
                                                }
                                                const format = manifest.formats[format_key]

                                                table_file.async("blob")
                                                    .then((blob) => {
                                                        console.log(blob)
                                                        const fileReader = new FileReader();
                                                        fileReader.onload = (evt) => {
                                                            update_callback({ running_status: 'Location table loaded.' })
                                                            const arrayBuffer = evt.target.result
                                                            const uint8Arr = new Uint8Array(arrayBuffer)
                                                            let rows = file_info.rows
                                                            const columns = format.columns
                                                            for (let c = 0; c < columns; c++) {
                                                                if (format.headers[c].startsWith('_')) {
                                                                    format.headers[c] = format.headers[c].slice(1)
                                                                }
                                                            }
                                                            if (uint8Arr.length != rows * columns * 4) {
                                                                console.error('file size mismatch: ', uint8Arr.length, rows * columns * 4)
                                                                reject2('file size does not match the manifest.')
                                                                return
                                                            }

                                                            const tableUint8Arrays = []
                                                            const tableArrays = []
                                                            for (let c = 0; c < columns; c++) {
                                                                tableUint8Arrays[c] = new Uint8Array(new ArrayBuffer(rows * 4))
                                                            }
                                                            if (format_version == 1) {
                                                                for (let c = 0; c < columns; c++) {
                                                                    for (let r = 0; r < rows * 4; r++) {
                                                                        tableUint8Arrays[c][r] = uint8Arr[r * columns + c]
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                for (let c = 0; c < columns; c++) {
                                                                    for (let r = 0; r < rows; r++) {
                                                                        tableUint8Arrays[c][4 * r] = uint8Arr[r * columns * 4 + 4 * c]
                                                                        tableUint8Arrays[c][4 * r + 1] = uint8Arr[r * columns * 4 + 4 * c + 1]
                                                                        tableUint8Arrays[c][4 * r + 2] = uint8Arr[r * columns * 4 + 4 * c + 2]
                                                                        tableUint8Arrays[c][4 * r + 3] = uint8Arr[r * columns * 4 + 4 * c + 3]
                                                                    }
                                                                }
                                                            }
                                                            const tableDict = {}
                                                            const tableUint8Dict = {}
                                                            for (let c = 0; c < columns; c++) {
                                                                tableArrays[c] = new Float32Array(tableUint8Arrays[c].buffer)
                                                                tableDict[format.headers[c]] = tableArrays[c]
                                                                tableUint8Dict[format.headers[c]] = tableUint8Arrays[c]
                                                            }

                                                            file_info.min = {}
                                                            file_info.max = {}
                                                            file_info.avg = {}
                                                            rows = tableArrays[0].length
                                                            for (let c = 0; c < columns; c++) {
                                                                const cn = format.headers[c]
                                                                file_info.min[cn] = Number.POSITIVE_INFINITY;
                                                                file_info.max[cn] = Number.NEGATIVE_INFINITY;
                                                                file_info.avg[cn] = 0;
                                                                for (let r = 0; r < rows; r++) {
                                                                    if (file_info.min[cn] > tableArrays[c][r]) {
                                                                        file_info.min[cn] = tableArrays[c][r]
                                                                        if (tableArrays[c][r] == 0) {
                                                                            console.log(cn, c, r)
                                                                        }
                                                                    }
                                                                    if (file_info.max[cn] < tableArrays[c][r])
                                                                        file_info.max[cn] = tableArrays[c][r]
                                                                    file_info.avg[cn] += tableArrays[c][r] / rows
                                                                }
                                                            }
                                                            data.headers = format.headers
                                                            for (let h = 0; h < data.headers.length; h++) {
                                                                data.headers[h] = data.headers[h].replace(/[^a-zA-Z0-9]+/g, '_').trim()
                                                            }
                                                            data.min = file_info.min
                                                            data.max = file_info.max
                                                            data.avg = file_info.avg
                                                            //TODO: Fix hash
                                                            data.tableUint8Arrays = tableUint8Arrays
                                                            data.tableArrays = tableArrays
                                                            data.tableUint8Dict = tableUint8Dict
                                                            data.tableDict = tableDict
                                                            data.columns = columns
                                                            Object.assign(data, file_info)
                                                            data.file_name = table_file.name
                                                            data.file_size = blob.size
                                                            file_info.data = data

                                                            file_info.data.integrity_test = false
                                                            const hash = this.calculate_hash(file_info)
                                                            if (!file_info.hash || file_info.hash != hash) {
                                                                file_info.data.integrity_test = false
                                                                console.log('integrity test failed: hash ' + file_info.hash + ' != ' + hash)
                                                            }
                                                            else {
                                                                file_info.data.integrity_test = true
                                                                console.log('integrity test passed: hash = ' + hash)
                                                            }
                                                            file_info.hash = hash
                                                            data.file_hash = hash

                                                            resolve2()
                                                        };
                                                        fileReader.onerror = (e) => {
                                                            reject2(e)
                                                        }
                                                        fileReader.readAsArrayBuffer(blob);
                                                    })
                                                    .catch((e) => {
                                                        reject2(e)
                                                    })
                                            }
                                            else if (file_info.type == "image") {
                                                update_callback({ running_status: 'Loading image file...' })

                                                const format_key = file_info.format

                                                // const format = manifest.formats[format_key]
                                                const image_file = zip.file(file_info.name)
                                                // console.log(image_file, format_key)
                                                if (!image_file) {
                                                    reject2('image file ' + manifest.image_file + ' is not present in the zip file.')
                                                    return
                                                }
                                                update_callback({ running_status: 'Uncompressing file: ' + file_info.name })
                                                image_file.async("blob")
                                                    .then((image_file) => {

                                                        var FR = new FileReader();
                                                        FR.onload = (e) => {
                                                            var img = new Image();
                                                            img.addEventListener("load", () => {
                                                                const data = {}
                                                                data.image = img
                                                                data.name = file_info.name || file.name
                                                                data.file_name = file_info.name || file.name
                                                                data.file_size = image_file.size || file.size
                                                                data.file_hash = file_info.hash
                                                                file_info.data = data
                                                                resolve2()
                                                                //context.drawImage(img, 0, 0);
                                                            });
                                                            img.src = e.target.result;
                                                        };
                                                        FR.onerror = (e) => {
                                                            reject2(e)
                                                        }
                                                        FR.readAsDataURL(image_file);

                                                    })
                                            }
                                        })
                                    }
                                }
                                load_files().then(() => {
                                    this.formats = manifest.formats
                                    this.files = manifest.files
                                    this.manifest = manifest
                                    this.manifest.tags = this.manifest.tags || []
                                    this.update_hash()
                                    this.zipFile = null
                                    this.uploaded = false
                                    // only files with a table can count as smlm
                                    this.isSMLM = true
                                    resolve(this.files)
                                }).catch((e) => {
                                    reject(e)
                                })

                            }).catch((e) => {
                                reject(e)
                            })
                    })
            });
        }
        calculate_hash(file_info) {
            console.log('calculating md5 for ', file_info.name)
            const spark = new SparkMD5.ArrayBuffer()
            if (file_info.type == 'table') {
                const dict = file_info.data.tableDict
                if (dict.frame) spark.append(dict.frame.buffer)
                if (dict.x) spark.append(dict.x.buffer)
                if (dict.y) spark.append(dict.y.buffer)
            }
            else if (file_info.type == 'image') {
                const dataURI = file_info.data.image.src
                const ab = this.dataURItoArrayBuffer(dataURI)
                spark.append(ab)
            }
            const hash = spark.end()
            console.log(file_info.name, ' hash: ', hash)
            return hash
        }
        update_hash() {
            let hash = ''
            const spark = new SparkMD5()
            for (let file_no = 0; file_no < this.files.length; file_no++) {
                if (this.files[file_no].hash) {
                    spark.append(this.files[file_no].hash)
                }
                else {
                    spark.append(this.files[file_no].name)
                }
            }
            this.manifest.hash = spark.end()
            console.log('update smlm file hash, name: ', this.manifest.name + ' md5: ' + this.manifest.hash)
        }
        dataURItoArrayBuffer(dataURI) {
            const byteString = atob(dataURI.split(',')[1]);
            const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return ab;
        }
        dataURItoFile(dataURI, file_name) {
            const byteString = atob(dataURI.split(',')[1]);
            const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            const blob = new Blob([ab], { type: mimeString });
            const name = file_name.split(".")[0] + "." + (mimeString.split('/')[1] || 'png')
            return new File([blob], name);
        }
        async saveAs(format) {
            if(!supported_text_formats[format]) throw new Error("Unsupported format: " + format)
            const format_config = supported_text_formats[format];
            const  delimiter = format_config.delimiter
            const header_transform = {}
            for(let k of Object.keys(format_config.header_transform)){
                header_transform[format_config.header_transform[k]]=k
            }
            await api.showMessage("Preparing...")
            await api.showProgress(0)
        
            for (let file_no = 0; file_no < this.files.length; file_no++) {
                const file_info = this.files[file_no]
                if (file_info.type == "table") {
                    // TODO: compare with existing format, if the same format already exist, reuse it.
                    const data = this.files[file_no].data
                    const tableDict = data.tableDict
                    const headers = []
                    for (let i = 0; i < data.headers.length; i++) {
                        headers.push(data.headers[i])
                    }

                    let content = ""
                    for(let header of headers){
                        content = content + (header_transform[header] || header)  + delimiter
                    }
                    content = content.slice(0, content.length-1) + '\n'
        
                    const rowCount = tableDict[headers[0]].length
                    const columns = headers.length;
                    const rows = [];
                    
                    for(let i=0;i<rowCount;i++){
                        for(let j=0;j<columns;j++){
                            rows.push(tableDict[headers[j]][i] + (j<columns-1?delimiter:'\n'));
                            // content = content + tableDict[headers[j]][i] + (j<columns-1?delimiter:'\n')
                        }

                        if(i%1000 === 0) {
                            await api.showMessage(`Converting ${i}/${rowCount}...`)
                            await api.showProgress(i/rowCount*100)
                        }
                    }
                    content = content + rows.join("");
                    const file = new File([content],file_info.name.split('.')[0] + format_config.extension, {
                        type: "text/plain",
                    })
                    await api.exportFile(file, file.name);
                    await api.showMessage(`Done, saving...`)
                    await api.showProgress(100)
                }
            }

           
        }
        save(save_file_name, update_callback) {
            if(save_file_name && !save_file_name.endsWith('.smlm')){
                throw new Error("Invalid file name, it must has .smlm extension: " + save_file_name)
            }
            update_callback = update_callback || function (status) {
                if(status.running_progress) api.showProgress(status.running_progress)
                if(status.running_status) api.showMessage(status.running_status)
            }
            api.showMessage('Preparing .smlm file...')
            return new Promise((resolve, reject) => {
                try {
                    if (this.zipFile) {
                        resolve(this.zipFile)
                        return
                    }
                    const zip = new JSZip()
                    update_callback({ running: true, running_progress: 0, running_status: "Preparing a compressed smlm file..." })
                    for (let file_no = 0; file_no < this.files.length; file_no++) {
                        const file_info = this.files[file_no]
                        if (file_info.type == "table") {
                            // TODO: compare with existing format, if the same format already exist, reuse it.
                            const format = JSON.parse(JSON.stringify(native_formats['smlm-table(binary)']))
                            const format_key = format.name + '-' + file_no
                            const data = this.files[file_no].data
                            const tableDict = data.tableDict

                            const tableUint8Arrays = []

                            for (let i = 0; i < data.headers.length; i++) {
                                tableUint8Arrays.push(new Uint8Array(tableDict[data.headers[i]].buffer))
                            }
                            const rows = tableUint8Arrays[0].length / 4
                            const columns = tableUint8Arrays.length

                            format.name = format_key
                            file_info.format = format_key
                            this.formats[format_key] = format
                            file_info.name = data.file_name.split(".")[0] + format.extension
                            file_info.hash = this.calculate_hash(file_info)
                            format.columns = columns
                            for (let i = 0; i < data.headers.length; i++) {
                                format.dtype[i] = "float32"
                                format.shape[i] = 1
                                format.headers[i] = data.headers[i].replace(/'/g, '').replace(/"/g, '').replace(/[^a-zA-Z0-9]+/g, '_').trim()
                                if (format.headers[i].startsWith('_')) {
                                    format.headers[i] = format.headers[i].slice(1)
                                }
                            }
                            console.log('preparing table ', file_info.name)
                            const buffer = new ArrayBuffer(rows * columns * 4)
                            const uint8Arr = new Uint8Array(buffer)
                            console.log('binary file size: ' + rows * columns * 4)

                            // for(let c=0;c<columns;c++){
                            //   for(let r=0;r<rows*4;r++){
                            //     uint8Arr[4*rows*c+r] = tableUint8Arrays[c][r]
                            //   }
                            // }
                            for (let c = 0; c < columns; c++) {
                                for (let r = 0; r < rows; r++) {
                                    uint8Arr[r * columns * 4 + 4 * c] = tableUint8Arrays[c][4 * r]
                                    uint8Arr[r * columns * 4 + 4 * c + 1] = tableUint8Arrays[c][4 * r + 1]
                                    uint8Arr[r * columns * 4 + 4 * c + 2] = tableUint8Arrays[c][4 * r + 2]
                                    uint8Arr[r * columns * 4 + 4 * c + 3] = tableUint8Arrays[c][4 * r + 3]
                                }
                            }
                            const blob = new Blob([uint8Arr]);
                            const file = new File([blob], file_info.name, { type: "application/octet-stream", lastModified: Date.now() });
                            console.log('file is ready.', file)
                            console.log('preparing file for upload...')
                            zip.file(file_info.name, file)
                        }
                        else if (file_info.type == 'image') {
                            const data = this.files[file_no].data
                            const dataURI = data.image.src
                            const file = this.dataURItoFile(dataURI, data.file_name)
                            file_info.hash = this.calculate_hash(file_info)
                            // var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]
                            // file_info.name = data.file_name.split(".")[0]+"."+(mimeString.split('/')[1]||'png')
                            //  var byteString = atob(dataURI.split(',')[1]);
                            //  var ab = new ArrayBuffer(byteString.length);
                            //  var ia = new Uint8Array(ab);
                            //  for (var i = 0; i < byteString.length; i++) {
                            //      ia[i] = byteString.charCodeAt(i);
                            //  }
                            //  var blob = new Blob([ab], {type: mimeString});
                            zip.file(file.name, file)
                        }
                    }
                    const manifest_ = Object.assign({}, this.manifest)
                    manifest_.format_version = manifest_template.format_version
                    const files_ = []
                    for (let i = 0; i < this.manifest.files.length; i++) {
                        const d = Object.assign({}, this.manifest.files[i])
                        delete d.data
                        files_.push(d)
                    }
                    manifest_.files = files_
                    this.update_hash()
                    console.log('smlm manifest: ', manifest_)
                    zip.file("manifest.json", JSON.stringify(manifest_, null, "\t"))
                    console.log('making zip archive...')
                    zip.generateAsync({
                        type: "blob",
                        compression: "DEFLATE",
                        compressionOptions: {
                            level: 9
                        }
                    },
                        (mdata) => {
                            update_callback({ running_status: "Making zip files... ", running_progress: mdata.percent })
                        }
                    ).then((zipBlob) => {
                        const zip_file_name = save_file_name || this.manifest.name
                        const zipFile = new File([zipBlob], zip_file_name, { type: "application/smlm", lastModified: Date.now() });
                        console.log(zipFile)
                        this.zipFile = zipFile
                        resolve(zipFile)
                        return
                    }).catch((e) => {
                        console.error(e)
                        reject(e)
                        return
                    })

                } catch (e) {
                    console.error(e)
                    reject(e)
                    return
                }

            })
        }
    }

    const supported_image_formats = {
        "png": {
            // Required
            "type": "image",
            "extension": ".png",
            "mode": "binary",
        },
        "jpg": {
            // Required
            "type": "image",
            "extension": ".jpg",
            "mode": "binary",
        },
        "jpeg": {
            // Required
            "type": "image",
            "extension": ".jpeg",
            "mode": "binary",
        }

    }

    const supported_text_formats = {
        "ThunderSTORM (csv)": {
            // Required
            "type": "table",
            "extension": ".csv",
            "mode": "text",
            "dtype": "float32",
            "delimiter": ",",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "x [nm]": "x", "y [nm]": "y", "z [nm]": "z", "uncertainty_xy [nm]": "uncertainty_xy", "uncertainty_z [nm]": "uncertainty_z" },

            // Optional
            "name": "ThunderSTORM (csv)",
            "description": "a csv format used in thunderSTORM"
        },
        "ThunderSTORM (xls)": {
            // Required
            "type": "table",
            "extension": ".xls",
            "mode": "text",
            "dtype": "float32",
            "delimiter": "\t",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "x [nm]": "x", "y [nm]": "y", "z [nm]": "z", "uncertainty_xy [nm]": "uncertainty_xy", "uncertainty_z [nm]": "uncertainty_z" },

            // Optional
            "name": "ThunderSTORM (xls)",
            "description": "a xls format used in thunderSTORM"
        },
        "ZEISS (txt)": {
            // Required
            "type": "table",
            "extension": ".txt",
            "mode": "text",
            "dtype": "float32",
            "delimiter": "\t",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "Position X [nm]": "x", "Position Y [nm]": "y", "Position Z [nm]": "z", "First Frame": "frame" },

            // Optional
            "name": "ZEISS (txt)",
            "description": "a txt format used in ZEISS microscope"
        },
        "ZEISSv1 (csv)": {
            // Required
            "type": "table",
            "extension": ".csv",
            "mode": "text",
            "dtype": "float32",
            "delimiter": ";",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "Position X [nm]": "x", "Position Y [nm]": "y", "Position Z [nm]": "z", "First Frame": "frame" },

            // Optional
            "name": "ZEISSv1 (csv)",
            "description": "a csv format used in ZEISS microscope"
        },
        "ZEISSv2 (csv)": {
            // Required
            "type": "table",
            "extension": ".csv",
            "mode": "text",
            "dtype": "float32",
            "delimiter": ";",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "x [nm]": "x", "y [nm]": "y", "z [nm]": "z", "First Frame": "frame" },

            // Optional
            "name": "ZEISSv2 (csv)",
            "description": "a csv format used for ZEISS microscope"
        },
        "RapidSTORM (txt)": {
            // Required
            "type": "table",
            "extension": ".txt",
            "mode": "text",
            "dtype": "float32",
            "delimiter": " ",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,

            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "*all*": 'identifier="([\\w\\d\\-_]+)"', "Position-0-0": "x", "Position-1-0": "y", "Position-2-0": "z", "ImageNumber-0-0": "frame" },

            // Optional
            "name": "RapidSTORM (txt)",
            "description": "a text format used in RapidSTORM"
        },
        "Space Seperated List (txt)": {
            // Required
            "type": "table",
            "extension": ".txt",
            "mode": "text",
            "dtype": "float32",
            "delimiter": " ",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,

            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": {},

            // Optional
            "name": "Space Seperated List (txt)",
            "description": "A list of coordinates seperated with space."
        },
        "Nikon NSTORM (txt)": {
            // Required
            "type": "table",
            "extension": ".txt",
            "mode": "text",
            "dtype": "float32",
            "delimiter": "\t",
            "comments": "",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": { "X": "x", "Y": "y", "Z": "z", "Frame": "frame" },

            // Optional
            "name": "Nikon NSTORM (txt)",
            "description": "a txt format exported from Nikon NSTORM software"
        },

    }

    const native_formats = {
        "smlm-table(binary)": {
            // Required
            "name": "smlm-table(binary)",
            "type": "table",
            "mode": "binary",
            "extension": ".bin",
            "columns": 0,
            "headers": [],
            "dtype": [],
            "shape": [],
            "units": [],
            // Optional
            "name": "smlm-table(binary)",
            "description": "the default smlm format for localization tables"
        },
        "smlm-image(binary)": {
            // Required
            "type": "image",
            "mode": "binary",
            "extension": ".raw",
            "dtype": "uint32",
            "shape": [512, 512, null],
            "offset": 0,
            // Optional
            "name": "smlm-image(binary)",
            "description": "a format for 32-bit raw pixel image"
        },
        "smlm-table(csv)": {
            // Required
            "type": "table",
            "mode": "text",
            "extension": ".csv",
            "dtype": "float32",
            "delimiter": ",",
            "comments": "#",
            // specify which row is the header, set to -1 if there is no header
            "header_row": 0,
            // specify how to transform the headers to the standard header defined in smlm format,
            "header_transform": {},

            // Optional
            "name": "smlm-table(csv)",
            "description": "a format for export as csv format"
        }
    }

    const manifest_template = {
        // Required
        "format_version": "0.2",

        "formats": {},

        "files": [],

        // Recommended
        "tags": [],
        "name": "",
        "description": "",
        // "thumbnail": "",
        "sample": "",
        "labeling": "",
        // "date": "",

        // Optional
        // "author": "",
        // "citation": "",
        // "email": "",
    }

    const file_info_template = {
        //Required
        "name": "",
        "format": "smlm-table(binary)",
        "channel": "default",
        "rows": 0,
        // specify offsets for column(s), if need. set to {} if no offset needed.
        "offset": {},

        //Optional
        "metadata": {},
        "exposure": -1,
    }

    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    async function fetchFile(url, showMessage, showProgress) {
        const response = await axios({
            url,
            method: 'GET',
            responseType: 'blob',
            cancelToken: source.token,
            onDownloadProgress: (progressEvent) => {
                showMessage(`Downloading file ${progressEvent.loaded / 1000}kB (${progressEvent.total && Math.round((progressEvent.loaded / progressEvent.total) * 100)}%)`);
                if (progressEvent.total)
                    showProgress(progressEvent.loaded / progressEvent.total)
            }
        })
        const filename = url.split('/').pop().split('#')[0].split('?')[0];
        const blob = new Blob([response.data]);
        const file = new File([blob], filename, { type: "application/octet-stream", lastModified: Date.now() });
        return file
    }

    class ImJoyPlugin {
        setup() {
            new smlmFile();
        }
        toNdArray(file) {
            var data = file.data
            var xx = data.tableDict.x
            var yy = data.tableDict.y
            var zz = data.tableDict.z
            var ff = data.tableDict.frame
            var rows = data.rows
            var table_dict = data.tableDict
            var progress = 0
            const array = new Float32Array(new ArrayBuffer(rows * 3 * 4))
            for (var line = 0; line < rows; line++) {
                var newProgress = Math.floor(100 * line / (rows + 0.5));
                if (newProgress != progress) {
                    progress = newProgress
                    api.showProgress(progress)
                }
                array[line * 3] = xx[line];
                array[line * 3 + 1] = yy[line];
                if (zz)
                    array[line * 3 + 2] = zz[line];
                else
                    array[line * 3 + 2] = -5.0e-6
            }
            return {
                _rtype: 'ndarray',
                _rdtype: 'float32',
                _rshape: [rows, 3],
                _rvalue: array.buffer,
            }
        }
        async render2d(file, window_id) {
            try {
                // const ret = await api.showDialog({name: 'rendering 2d', type: 'joy', ui: "Render a 2D histogram with: <br>pixel size={id:'pixel_size', type:'number', placeholder: 20}nm<br> width={id:'width', type:'number', placeholder: 2560} <br> height={id:'height', type:'number', placeholder: 2560}"})
                api.showStatus("rendering...")
                var pixel_size = 20
                var data = file.data
                var width = parseInt(data.max.x / pixel_size + 0.5)
                var height = parseInt(data.max.y / pixel_size + 0.5)
                var canvas_data = new Uint16Array(new ArrayBuffer(width * height * 2)); //uint16

                var xx = data.tableDict.x
                var yy = data.tableDict.y
                var ff = data.tableDict.frame
                var rows = data.rows
                var table_dict = data.tableDict
                var isFiltered = data.isFiltered
                var progress = 0
                for (var line = 0; line < rows; line++) {
                    var newProgress = Math.floor(100 * line / (rows + 0.5));
                    if (newProgress != progress) {
                        progress = newProgress
                        api.showProgress(progress)
                    }
                    if (isFiltered && !isFiltered[line]) continue
                    var f = parseInt(ff[line])
                    var x = parseInt(xx[line] / pixel_size)
                    var y = parseInt(yy[line] / pixel_size)
                    if (!f || !x || !y) {
                        continue
                    }
                    if (y > height || x > width) continue
                    var s = y * width + x;  // calculate the index in the array
                    canvas_data[s] = canvas_data[s] + 1
                }
                api.showStatus("histogram rendered.")
                console.timeEnd('plot histogram')
                return await api.createWindow({
                    src: "https://kitware.github.io/itk-vtk-viewer/app/",
                    data: {
                        image: {
                            _rtype: 'ndarray',
                            _rdtype: 'uint16',
                            _rshape: [height, width],
                            _rvalue: canvas_data.buffer,
                        }
                    }, window_id
                })
                // const image = {type: 'image/grayscale', array: canvas_data, height: height, width: width} // table: files[0].data
                // await api.createWindow({name: 'Histogram', type: 'Image Window', data: image, w: 10, h: 10, config: {}, window_id: window_id})

                //return my
            } catch (e) {
                console.error(e)
                throw e
            }

        }

        async cancel(){
            source.cancel('Operation canceled by the user.');
        }

        async load(files) {
            if(!Array.isArray(files)) files = [files];
            const smlm = new smlmFile();
            for(let file of files){
                if(typeof file === 'string' && file.startsWith('http'))
                    file = await fetchFile(file, api.showMessage, api.showProgress)
                // const blob2 = file.slice(0, 3)
                // console.log(await blob2.text())
                if (file.name.endsWith('.smlm')) {
                    await this._loadSmlmFile(smlm, file)
                }
                else {
                    await new Promise((resolve, reject) => {
                        var r = new FileReader();
                        var blob = file.slice(0, 100);
                        r.onload = (evt) => {
                            let textFormat = null;
                            const sampleLines = evt.target.result.split('\n').slice(0, 2)
                            if (sampleLines[0].includes('x [nm]') && sampleLines[0].includes('\t')) {
                                textFormat = 'ThunderSTORM (xls)'
                            }
                            else if (sampleLines[0].includes('x [nm]') && sampleLines[0].includes(',')) {
                                textFormat = 'ThunderSTORM (csv)'
                            }
                            else if (sampleLines[0].includes('Position X [nm]') && sampleLines[0].includes('\t')) {
                                textFormat = 'ZEISS (txt)'
                            }
                            else if (sampleLines[0].includes('Position X [nm]') && sampleLines[0].includes(';')) {
                                textFormat = 'ZEISSv1 (csv)'
                            }
                            else if (sampleLines[0].includes('x [nm]') && sampleLines[0].includes(';')) {
                                textFormat = 'ZEISSv2 (csv)'
                            }
                            else if (sampleLines[0].startsWith('#') && sampleLines[0].includes('identifier=')) {
                                textFormat = 'RapidSTORM (txt)'
                            }
                            else if (sampleLines[0].includes('x ') && sampleLines[0].includes('y ')) {
                                textFormat = 'Space Seperated List (txt)'
                            }
                            else if (sampleLines[0].includes('X\t') && sampleLines[0].includes('\tY\t') && sampleLines[0].includes('Channel Name')) {
                                textFormat = 'Nikon NSTORM (txt)'
                            }
                            // else if (file.name.endsWith('.png')) {
                            //     textFormat = 'png'
                            // }
                            // else if (file.name.endsWith('.jpg')) {
                            //     textFormat = 'jpg'
                            // }
                            // else if (file.name.endsWith('.jpeg')) {
                            //     textFormat = 'jpeg'
                            // }
                            if (textFormat) {
                                resolve(this._loadTextFile(smlm, file, textFormat, true))
                            }
                            else {
                                reject('File format is not recognized: ' + file.name)
                            }

                        };
                        r.onerror = (e) => {
                            console.error(e)
                            reject(`Failed to read file: ${e}`)
                        }
                        r.readAsText(blob);
                    })
                }
            }
           
            return {_rintf: true, files: smlm.files, manifest: smlm.manifest, save: smlm.save.bind(smlm), saveAs: smlm.saveAs.bind(smlm) }

        }

        async _loadTextFile(smlm, file, format, is_append) {
            console.time('load text file', format);
            const file_info = await smlm.import_text_table(file, format, {}, is_append, (status) => {
                status.running_prgress && api.showProgress(status.running_prgress)
                status.running_status && api.showStatus(status.running_status)
            })
            console.timeEnd('load text file');
            console.log(file_info)
            const metadata = file_info.metadata
        }

        async _loadSmlmFile(smlm, selectedFile, is_append) {
            
            console.time('import smlm')
            await smlm.import_smlm(selectedFile, is_append, (status) => {
                status.running_prgress && api.showProgress(status.running_prgress)
                status.running_status && api.showStatus(status.running_status)
            })
            
            console.timeEnd('import smlm')
            console.time('plot histogram')
            console.log('smlm file loaded: ', smlm.files)
            console.log('manifest: ', smlm.manifest)
        }

        async show(file, windowId) {
            const smlm = await this.load(file)
            const viewer = await api.createWindow({
                src: "https://kitware.github.io/itk-vtk-viewer/app/",
                window_id: windowId
            })
            const sets = []
            let is3d = false;
            for (let f of smlm.files) {
                sets.push(this.toNdArray(f))
                if (f.data.headers.includes('z')) {
                    is3d = true
                }
            }
            await viewer.setPointSets(sets);
            await viewer.setBackgroundColor([0, 0, 0]);
            await viewer.setAxesEnabled(false);
            if (is3d)
                await viewer.setViewMode('Volume');
            else
                await viewer.setViewMode('ZPlane');
            this.viewer = viewer;

        }

        async capture() {
            if (!this.viewer) throw new Error("no viewer is created");
            return await this.viewer.captureImage();
        }

        async run(ctx) {
            if (ctx && ctx.data instanceof Blob) {
                throw "You should provide a file to parse"
                return
            }
            const windowId = my.config && my.config.window_id;
            await this.show(ctx.data, windowId)
        }
    }

    api.export(new ImJoyPlugin())
</script>